## 为什么需要数据结构？

先回答一下问题：

- #### 问题一：为什么大多数编程语言中，数组要从 0 开始编号，而不是从 1 开始呢？

  > 从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。
  >
  > 
  >
  > 数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开始。
  >
  > 
  >
  > C 语言设计者用 0 开始计数数组下标，之后的 Java、JavaScript 等高级语言都效仿了 C 语言，或者说，为了在一定程度上减少 C 语言程序员学习 Java 的学习成本，因此继续沿用了从 0 开始计数的习惯。实际上，很多语言中数组也并不是从 0 开始计数的，比如 Matlab。甚至还有一些语言支持负数下标，比如 Python。



[数据结构与算法学习书单推荐 · geeker\-courses](https://mendylee.gitbooks.io/geeker-study-courses/content/zhuan-ye-ji-chu-pian/li-lun-xue-ke/shu-ju-jie-gou-yu-suan-fa/shu-ju-jie-gou-yu-suan-fa-xue-xi-shu-dan-tui-jian.html)





## 线性表

- 数组
- 链表
- 栈
- 队列



> 数组。它可以说是最基础、最简单的数据结构了。
>
> 数组用一块连续的内存空间，来存储相同类型的一组数据，
>
> `最大的特点就是支持随机访问，但插入、删除操作也因此变得比较低效，平均情况时间复杂度为 O(n)。`在平时的业务开发中，我们可以直接使用编程语言提供的容器类，但是，如果是特别底层的开发，直接使用数组可能会更合适。
>
> 
>
> 针对数组类型，很多语言都提供了容器类，比如 Java 中的 ArrayList、C++ STL 中的 vector。在项目开发中，什么时候适合用数组，什么时候适合用容器呢？
>
> 作为高级语言编程者，是不是数组就无用武之地了呢？当然不是，有些时候，用数组会更合适些，我总结了几点自己的经验。
>
> 1.Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而 Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。
>
> 2. 如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组。
> 3.  还有一个是我个人的喜好，当要表示多维数组时，用数组往往会更加直观。比如 Object[][] array；而用容器的话则需要这样定义：ArrayList<ArrayList<object> > array。我总结一下，对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。但如果你是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。

![](https://pic.imgdb.cn/item/624470e527f86abb2acf2816.jpg)



#### 问题2：如何用链表来实现 LRU 缓存淘汰策略呢？

如何基于链表实现 LRU 缓存淘汰算法？

我的思路是这样的：我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。

当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。

1. 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。
2. 如果此数据没有在缓存链表中，又可以分为两种情况：
   1. 如果此时缓存未满，则将此结点直接插入到链表的头部；
   2. 如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。
   3. 这样我们就用链表实现了一个 LRU 缓存，是不是很简单？现在我们来看下缓存访问的时间复杂度是多少。
   4. 因为不管缓存有没有满，我们都需要遍历一遍链表，所以这种基于链表的实现思路，缓存访问的时间复杂度为 O(n)。实际上，我们可以继续优化这个实现思路，比如引入散列表（Hash table）来记录每个数据的位置，将缓存访问的时间复杂度降到 O(1)。因为要涉及我们还没有讲到的数据结构，所以这个优化方案，我现在就不详细说了，等讲到散列表的时候，我会再拿出来讲。除了基于链表的实现思路，实际上还可以用数组来实现 LRU 缓存淘汰策略。

#### 问题3：如何利用数组实现 LRU 缓存淘汰策略呢？







## 非线性表

- 树
- 图



![](https://pic.imgdb.cn/item/6244712027f86abb2acfc6df.jpg)