[437\. 路径总和 III \- 力扣（Leetcode）](https://leetcode.cn/problems/path-sum-iii/description/?favorite=2cktkvj)



给定一个二叉树的根节点 `root` ，和一个整数 `targetSum` ，求该二叉树里节点值之和等于 `targetSum` 的 **路径** 的数目。

**路径** 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg)

```
输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
输出：3
解释：和等于 8 的路径有 3 条，如图所示。
```

**示例 2：**

```
输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：3
```

 

**提示:**

- 二叉树的节点个数的范围是 `[0,1000]`
- `-109 <= Node.val <= 109` 
- `-1000 <= targetSum <= 1000` 



### 递归遍历 248 ms击败20%

```swift
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public var val: Int
 *     public var left: TreeNode?
 *     public var right: TreeNode?
 *     public init() { self.val = 0; self.left = nil; self.right = nil; }
 *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }
 *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {
 *         self.val = val
 *         self.left = left
 *         self.right = right
 *     }
 * }
 */
class Solution {
    // 从任意一个节点开始向下查找：先序遍历 
    // 如果路径和与targeSum相等，sum+=1
    func nodeSum(_ root: TreeNode?, _ targetSum: Int) -> Int {
        if root == nil { return 0 }
        var res: Int = 0
        if root?.val == targetSum { res += 1 }
        res += nodeSum(root?.left, targetSum - root!.val)
        res += nodeSum(root?.right, targetSum - root!.val)
        return res
    }
    func pathSum(_ root: TreeNode?, _ targetSum: Int) -> Int {
        // nodeSum(root, targetSum) = nodeSum(root.left, targetSum - val) + nodeSum(roo.right, targetSum - val)
        guard let root = root else { return 0 }
        // 先序遍历找到从root出发结果为targetSum的总数
        var sum = nodeSum(root, targetSum)
        // 从左子树出发结果是targetSum的数量
        sum += pathSum(root.left, targetSum)
        // 从右子树出发结果是targetSum的数量
        sum += pathSum(root.right, targetSum)

        return sum
    }
}
```

### 前缀和Java

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int pathSum(TreeNode root, int sum) {
        // key是前缀和, value是大小为key的前缀和出现的次数
        Map<Long, Integer> prefixSumCount = new HashMap<>();
        // 前缀和为0的一条路径
        prefixSumCount.put(0L, 1);
        // 前缀和的递归回溯思路
        return recursionPathSum(root, prefixSumCount, sum, 0L);
    }

    /**
     * 前缀和的递归回溯思路
     * 从当前节点反推到根节点(反推比较好理解，正向其实也只有一条)，有且仅有一条路径，因为这是一棵树
     * 如果此前有和为currSum-target,而当前的和又为currSum,两者的差就肯定为target了
     * 所以前缀和对于当前路径来说是唯一的，当前记录的前缀和，在回溯结束，回到本层时去除，保证其不影响其他分支的结果
     * @param node 树节点
     * @param prefixSumCount 前缀和Map
     * @param target 目标值
     * @param currSum 当前路径和
     * @return 满足题意的解
     */
    private int recursionPathSum(TreeNode node, Map<Long, Integer> prefixSumCount, int target, long currSum) {
        // 1.递归终止条件
        if (node == null) {
            return 0;
        }
        // 2.本层要做的事情
        int res = 0;
        // 当前路径上的和
        currSum += node.val;

        //---核心代码
        // 看看root到当前节点这条路上是否存在节点前缀和加target为currSum的路径
        // 当前节点->root节点反推，有且仅有一条路径，如果此前有和为currSum-target,而当前的和又为currSum,两者的差就肯定为target了
        // currSum-target相当于找路径的起点，起点的sum+target=currSum，当前点到起点的距离就是target
        res += prefixSumCount.getOrDefault(currSum - target, 0);
        // 更新路径上当前节点前缀和的个数
        prefixSumCount.put(currSum, prefixSumCount.getOrDefault(currSum, 0) + 1);
        //---核心代码

        // 3.进入下一层
        res += recursionPathSum(node.left, prefixSumCount, target, currSum);
        res += recursionPathSum(node.right, prefixSumCount, target, currSum);

        // 4.回到本层，恢复状态，去除当前节点的前缀和数量
        prefixSumCount.put(currSum, prefixSumCount.get(currSum) - 1);
        return res;
    }
}

作者：失火的夏天
链接：https://leetcode.cn/problems/path-sum-iii/solutions/100992/qian-zhui-he-di-gui-hui-su-by-shi-huo-de-xia-tian/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

### 前缀和Swift

```swift
var prefix: [Int: Int] = [:]
    func pathSum(_ root: TreeNode?, _ targetSum: Int) -> Int {
        prefix[0] = 1
        return dfs(root, 0, targetSum)
    }

    func dfs(_ root: TreeNode?, _ current: Int, _ targetSum: Int) -> Int {
        guard let root = root else {  return 0 }
        var current = current, result = 0
        current += root.val
        if let num = prefix[current - targetSum] {
            result = num
        }
        prefix[current] = prefix[current] ?? 0 + 1
        result += dfs(root.left, current, targetSum)
        result += dfs(root.right, current, targetSum)
        prefix[current] = prefix[current] ?? 0 - 1 
        return result
    }
```

