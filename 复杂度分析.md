



### 为什么需要复杂度分析？

你可能会有些疑惑，我把代码跑一遍，通过统计、监控，就能得到算法执行的时间和占用的内存大小。



为什么还要做时间、空间复杂度分析呢？这种分析方法能比我实实在在跑一遍得到的数据更准确吗？首先，我可以肯定地说，你这种评估算法执行效率的方法是正确的。很多数据结构和算法书籍还给这种方法起了一个名字，叫`事后统计法`



但是，这种统计方法有非常大的局限性。

#### 1、测试结果非常依赖测试环境

测试环境中硬件的不同会对测试结果有很大的影响。比如，我们拿同样一段代码，分别用 Intel Core i9 处理器和 Intel Core i3 处理器来运行，不用说，i9 处理器要比 i3 处理器执行的速度快很多。还有，比如原本在这台机器上 a 代码执行的速度比 b 代码要快，等我们换到另一台机器上时，可能会有截然相反的结果。

#### 2、测试结果受数据规模的影响很大

后面我们会讲排序算法，我们先拿它举个例子。对同一个排序算法，待排序数据的有序度不一样，排序的执行时间就会有很大的差别。极端情况下，如果数据已经是有序的，那排序算法不需要做任何操作，执行时间就会非常短。除此之外，如果测试数据规模太小，测试结果可能无法真实地反映算法的性能。比如，对于小规模的数据排序，插入排序可能反倒会比快速排序要快！

**所以，我们需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法。**
这就是我们今天要讲的时间、空间复杂度分析方法。



### 1 大 O 时间复杂度表示法

算法的执行效率，粗略地讲，就是算法代码执行的时间。但是，如何在不运行代码的情况下，用“肉眼”得到一段代码的执行时间呢？这里有段非常简单的代码，求 1,2,3...n 的累加和。现在，我就带你一块来估算一下这段代码的执行时间。

```c

 int cal(int n) {
   int sum = 0;
   int i = 1;
   for (; i <= n; ++i) {
     sum = sum + i;
   }
   return sum;
 }
```

从 CPU 的角度来看，这段代码的每一行都执行着类似的操作：`读数据-运算-写数据`。尽管每行代码对应的 CPU 执行的个数、执行的时间都不一样，但是，`我们这里只是粗略估计，所以可以假设每行代码执行的时间都一样，为 unit_time`。在这个假设的基础之上，这段代码的总执行时间是多少呢？

第 2、3 行代码分别需要 1 个 unit_time 的执行时间，第 4、5 行都运行了 n 遍，所以需要 2n*unit_time 的执行时间，所以这段代码总的执行时间就是 (2n+2)*unit_time。可以看出来，**所有代码的执行时间 T(n) 与每行代码的执行次数成正比。**



按照这个分析思路，我们再来看这段代码。

```c
int cal(int n) {
   int sum = 0;
   int i = 1;
   int j = 1;
   for (; i <= n; ++i) {
     j = 1;
     for (; j <= n; ++j) {
       sum = sum +  i * j;
     }
   }
 }
```



我们依旧假设每个语句的执行时间是 unit_time。那这段代码的总执行时间 T(n) 是多少呢？

第 2、3、4 行代码，每行都需要` 1 个 unit_time 的执行时间`

第 5、6 行代码循环执行了 n 遍，需要` 2n * unit_time 的执行时间`，

第 7、8 行代码循环执行了 $n^2$遍，`需要 2$n^2$ * unit_time 的执行时间`。

所以，`整段代码总的执行时间 T(n) = (2$n^2$+2n+3)*unit_time。`



尽管我们不知道 unit_time 的具体值，但是通过这两段代码执行时间的推导过程，

我们可以得到一个非常重要的规律，那就是，`所有代码的执行时间 T(n) 与每行代码的执行次数 f(n) 成正比。`



我们可以把这个规律总结成一个公式。注意，大 O 就要登场了！

![](https://static001.geekbang.org/resource/image/22/ef/22900968aa2b190072c985a08b0e92ef.png)



我来具体解释一下这个公式。其中，

`T(n) 我们已经讲过了，它表示代码执行的时间；n 表示数据规模的大小；`

`f(n) 表示每行代码执行的次数总和。`因为这是一个公式，所以用 f(n) 来表示。

`公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。`

所以，第一个例子中的 T(n) = O(2n+2)，第二个例子中的 T(n) = O(2$n^2$+2n+3)。这就是大 O 时间复杂度表示法。

`大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。`

### 2 时间复杂度

####  1. 只关注循环执行次数最多的一段代码

#### 2、加法原则：总时间复杂度等于量级最大的那一段代码的复杂度

#### 3、乘法原则：嵌套代码的时间复杂度等于嵌套内外代码复杂度的乘积



#### 常见的时间复杂度

![](https://static001.geekbang.org/resource/image/37/0a/3723793cc5c810e9d5b06bc95325bf0a.jpg)



###  空间复杂度

前面我讲过，时间复杂度的全称是`渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系。`

类比一下，空间复杂度全称就是`渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。`



![](https://pic.imgdb.cn/item/62446f6b27f86abb2acba99e.jpg)



## 总结

复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，

可以粗略地表示，越高阶复杂度的算法，执行效率越低。

`常见的复杂度并不多，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n2 )。等你学完整个专栏之后，你就会发现几乎所有的数据结构和算法的复杂度都跑不出这几个。`

![](https://static001.geekbang.org/resource/image/49/04/497a3f120b7debee07dc0d03984faf04.jpg)

`复杂度分析并不难，关键在于多练。`

